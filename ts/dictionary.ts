// -*- js -*-
// Copyright © 2018 by Ezer IT Consulting. All rights reserved. E-mail: claus@ezer.dk


// This code handles the interpretation of the 'dictionaries' variable generated by the server PHP code


//****************************************************************************************************
// DictionaryIf interface
//
// This interface and the 'dictionaries' variable are described in the Technical Documentation in the
// chapter entitled "The dictionaries Variable". They will not be documented here.
//
interface DictionaryIf {
    sentenceSets : MonadSet[];
    sentenceSetsQuiz : MonadSet[];
    monadObjects: MonadObject[][][]; // First index is sentence set number, second index is level (word, phrase, clause etc.), third index gives the actual object
    bookTitle : string;
}


declare let dictionaries : DictionaryIf; // Generated by the server PHP code


//****************************************************************************************************
// About the relationship between the MonadObject and DisplayMonadObject classes
//****************************************************************************************************
//
// The server code places information about Emdros objects in the 'monadObjects' field of the
// DictionaryIf interface. Each element in the 'monadObjects' field is an object of class MonadObject.
// The MonadObjects are ordered in a hierarchy using the 'children_idds' field of the MonadObject.
//
// When the client code calls the constructor of the Dictionary class below, it adds a 'parent'
// field to the MonadObject, resulting in a doubly linked hierarchy.
//
// The constructor also creates a parallel hierachy of DisplayMonadObjects, which contain
// information about how the Emdros objects are displayed in HTML.
//
// The MonadObject class has two subclasses, SingleMonadObject (which represents a word) and
// MultipleMonadObject (which represents a phrase or clause etc.). Similarly, the DisplayMonadObject
// class has two subclasses, DisplaySingleMonadObject and DisplayMultipleMonadObject. Although the
// two sets of classes are releated, there is a difference in the way split Emdros objects are
// handled. (A split Emdros object is, for example, a clause which contains another clause.) A split
// Emdros object is handled by one MultipleMonadObject but by several DisplayMultipleMonadObjects,
// one for each segment of the split Emdros object.
//
// When the constructor below creates the hierarchy of DisplayMonadObjects, the MonadObjects
// will be tied to the DisplayMonadObjects thus:
//    The 'displayMo' field of DisplayMonadObject contains the corresponding MonadObject.
//    The 'displayers' field of MonadObject is an array containing the corresponding DisplayMonadObjects.
//
//****************************************************************************************************



//****************************************************************************************************
// Dictionary class
//
// This class is responsible for interpreting the contents of the 'dictionaries' variable and
// generating the corresponding HTML code.
//
class Dictionary {
    // The fields sentenceSet, monadobjects1 and bookTitle contain data extracted from the dictionaries variable.
    public sentenceSet     : MonadSet;      // A single MonadSet from dictionaries.sentenceSets
    public sentenceSetQuiz : MonadSet;      // A single MonadSet from dictionaries.sentenceSetsQuiz
    public monadObjects1 : MonadObject[][]; // A single 2-D array from dictionaries.monadObjects.
                                            // The first index is level (word, phrase, clause etc.),
                                            // the second index gives the actual object
    public bookTitle     : string;          // Identical to dictionaries.bookTitle

    
    public monads           : MonadObject[]          = []; // Maps id_d => monad object
    public level            : number[]               = []; // Maps id_d => object level
    private singleMonads    : SingleMonadObject[]    = []; // Maps monad number => SingleMonadObject (words only)
    public dispMonadObjects : DisplayMonadObject[][] = []; // The Emdros objects to display.
                                                           // The first index is level (word, phrase, clause etc.),
                                                           // the second index gives the actual object

    private hideWord : boolean; // Should the question object be replaced by numbers in the text?
    

    //------------------------------------------------------------------------------------------
    // Constructor method
    //
    // Parameters:
    //     dictif: The DictionaryIf object to interpret.
    //     index: The entry in dictif.sentenceSets and dictif.monadObjects to interpret.
    //     qd: Quiz information if we are generating an exercise, otherwise null.
    //
    constructor(dictif : DictionaryIf, index : number, qd : QuizData) {
        // Save local copy of relevant information
        this.sentenceSet = dictif.sentenceSets[index];
        this.sentenceSetQuiz = dictif.sentenceSetsQuiz==null ? null : dictif.sentenceSetsQuiz[index];
        this.monadObjects1 = dictif.monadObjects[index];
        this.bookTitle = dictif.bookTitle;
        this.hideWord = (qd!=null && qd.quizFeatures.dontShow);

        // Generate the 'singleMonads', 'monads' and 'level' maps.
        for (let level in this.monadObjects1) {
            let leveli : number = +level;
            if (isNaN(leveli)) continue; // Not numeric
            // leveli is 0 for word, 1 for phrase, etc. (or something similar depending on the database)

            for (let i in this.monadObjects1[leveli]) {
                if (isNaN(+i)) continue; // Not numeric

                let item : MonadObject = this.monadObjects1[leveli][+i]; // A single Emdros object
                if (leveli===0) 
                    this.singleMonads[getSingleInteger(item.mo.monadset)] = item as SingleMonadObject;
                this.monads[item.mo.id_d] = item;
                this.level[item.mo.id_d] = leveli;
            }
        }

        // Bind parents and children of the MonadObject hierarchy
	for (let i in this.monads) {
            if (isNaN(+i)) continue; // Not numeric

	    let parent : MonadObject = this.monads[+i];
	    for (let i2 in parent.children_idds) {
                if (isNaN(+i2)) continue; // Not numeric

		let child_idd : number = parent.children_idds[+i2];
                this.monads[child_idd].parent = parent;
            }
        }


        ///////////////////////////
        // Create display hierarchy

        // Single monads (i.e. words)
        this.dispMonadObjects.push([]);

        for (let se in this.singleMonads) {
            if (isNaN(+se)) continue; // Not numeric

            // singleMonads is sparsely populated
	    this.dispMonadObjects[0].push( new DisplaySingleMonadObject(this.singleMonads[+se],
                                                                        configuration.sentencegrammar[0].objType,
                                                                        qd!=null) );
        }

        // Multiple monads (i.e. phrases, clauses, etc.)
        for (let lev : number = 1; lev<configuration.maxLevels; ++lev) {
            let ldmo : DisplayMonadObject[] = []; // The Emdros objects at level 'lev'

            this.dispMonadObjects.push(ldmo);

            if (lev<configuration.maxLevels-1) { // Not top level
                for (let i in this.monadObjects1[lev]) {
                    if (isNaN(+i)) continue; // Not numeric

                    let monadObject : MonadObject = this.monadObjects1[lev][parseInt(i)]; // The current object

                    // Split object into contiguous segments
                    let segCount : number = monadObject.mo.monadset.segments.length;
                    
                    for (let mix : number = 0; mix<segCount; ++mix) {
                        let mp : MonadPair = monadObject.mo.monadset.segments[mix];
                        ldmo.push( new DisplayMultipleMonadObject(monadObject as MultipleMonadObject,
                                                                  configuration.sentencegrammar[lev].objType,
                                                                  lev,
                                                                  mp,
                                                                  mix,
                                                                  mix>0, 
                                                                  mix<segCount-1) );
                    }
                }

                // Sort ldmo in monad order
                ldmo.sort(
                    function(a : DisplayMonadObject, b : DisplayMonadObject) {
                        return a.range.low - b.range.low;
                    });
            }
            else { // Top level
                // At the top level there is always only one DisplayMultipleMonadObject
                let monadObject : MonadObject = this.monadObjects1[lev][0];
                ldmo.push( new DisplayMultipleMonadObject(monadObject as MultipleMonadObject,
                                                          'Patriarch', // The pseudo-name of the top-level object
                                                          lev,
                                                          monadObject.mo.monadset) );
            }
        }


        /////////////////////////////////////////////////////////
        // Construct child-parent linkage for DisplayMonadObjects

        for (let lev : number = 1; lev<configuration.maxLevels; ++lev) {
            // Find constituent MonadObjects
            
            // Loop through monads at level lev
            for (let parentDmoIx in this.dispMonadObjects[lev]) {
                if (isNaN(+parentDmoIx)) continue; // Not numeric

                let parentDmo : DisplayMonadObject = this.dispMonadObjects[lev][+parentDmoIx];

                // Loop through mondads at child level
                for (let childDmoIx in this.dispMonadObjects[lev-1]) {
                    if (isNaN(+childDmoIx)) continue; // Not numeric

                    let childDmo : DisplayMonadObject = this.dispMonadObjects[lev-1][+childDmoIx];
                    if (childDmo.containedIn(parentDmo)) {
                        // We found a child
                        if (childDmo.parent!=undefined) throw 'BAD1'; // Ensures that the tree is properly constructed
                        childDmo.parent = parentDmo as DisplayMultipleMonadObject;
                        parentDmo.children.push(childDmo);
                    }
                }
            }
        }
    }

    //------------------------------------------------------------------------------------------
    // hoverForGrammar method
    //
    // Associate a grammar information box with each Emdros object. The grammar information box is
    // displayed when the mouse hovers over the object.
    //
    // This function is called only if the display size is large enough to have room for a grammar
    // information box.
    //
    private hoverForGrammar() {
        let thisDict : Dictionary = this;

        // All display objects are identified with a "data-idd" attribute in the displaying HTML element.
        
        if (useTooltip) {
            // Use the tooltip function of JQuery UI.
            $(document).tooltip(
                {
                    items: "[data-idd]",
                    disabled: false, 
                    content: function() { return thisDict.toolTipFunc(this, true)[0]; }
                });
        }
        else {
            // Poplulate the <div class="grammardisplay"> element with grammar information when the
            // mouse hovers over a displayed object.
            $("[data-idd]")
                .hover(
                    function() {
                        // Calculate vertical position of '.grammardisplay'.
                        // It should be placed at least 20px from top of window but not higher
                        // than '#textcontainer'
                        let scrTop   : number = $(window).scrollTop();
                        let qcTop    : number = $('#textcontainer').offset().top;
                        $('.grammardisplay')
                            .html(thisDict.toolTipFunc(this, true)[0])
                            .css('top',Math.max(0,scrTop-qcTop+5))
                            .outerWidth($('#grammardisplaycontainer').outerWidth()-25) // 25px is a littel more than margin-right
                            .show();
                    },
                    function () {
                        $('.grammardisplay').hide();
                    }
                );
        }
    }

    //------------------------------------------------------------------------------------------
    // dontHoverForGrammar method
    //
    // Disassociate a grammar information box with each Emdros object.
    //
    // This function is called if the display size is too narrow to have room for a grammar
    // information box.
    //
    private dontHoverForGrammar() {
        // All display objects are identified with a "data-idd" attribute in the displaying HTML element.
        
        if (useTooltip)
            $(document).tooltip({items: "[data-idd]", disabled: true});
        else
            $("[data-idd]").off("mouseenter mouseleave");
    }
 
    //------------------------------------------------------------------------------------------
    // clickForGrammar method
    //
    // Associate a popup grammar information box with each Emdros object. The popup grammar
    // information box is displayed when the user clicks on the object.
    //
    private clickForGrammar() {
        // All display objects are identified with a "data-idd" attribute in the displaying HTML element.

        $("[data-idd]").on('click', (event : any) => {
            let [contents, heading] : [string, string] = this.toolTipFunc(event.currentTarget, false);
            $('#grammar-info-label').html(heading);
            $('#grammar-info-body').html(contents);
            $('#grammar-info-dialog').modal('show');
        });
    }

    //------------------------------------------------------------------------------------------
    // handleDisplaySize static method
    //
    // This function is called when the display size changes. It enables or disables the grammar
    // information box depending on the display size.
    //
    // Parameter:
    //     thisDict: The current Dictionary object
    //
    private static handleDisplaySize(thisDict : Dictionary) {
        switch (resizer.getWindowSize()) {
        case 'xs':
        case 'sm':
            thisDict.dontHoverForGrammar(); // Disable grammar information box
            break;

        default:
            thisDict.hoverForGrammar(); // Enable grammar information box
            break;
        }
    }

    //------------------------------------------------------------------------------------------
    // boxes static method
    //
    // Generates a string with an appropriate number of small squares (Unicode character 25AA (▪))
    // to indicate indentation size. This is currently only used for displaying indentation of
    // clauses in the ETCBC4 database.
    //
    // Parameters:
    //     num: The current indentation.
    //     minnum: The minimum indentitation in the current text.
    //     maxnum: The maximum indentitation in the current text.
    // Returns:
    //     A string containing the appropriate number of squares.
    //
    private static boxes(num : number, minnum : number, maxnum : number) : string {
        let s = '';
        let numspaces = num < 10 ? num : num-1;  // If num has two digits, we write one space less

        for (let i=minnum; i<numspaces; ++i) 
            s += '\u00a0';  // Unicode NO-BREAK SPACE

        s += num;

        for (let i=num; i<=maxnum; ++i)
            s += '\u25aa';  // Unicode BLACK SMALL SQUARE

        return s;
    }


    //------------------------------------------------------------------------------------------
    // generateSentenceHtml method
    //
    // Generates HTML code to display the current text and its grammar information. The text is
    // stored in the <div id="textarea"> HTML element and is also the return value from this
    // function. The return value is used if we are generating an exercise, in which case the text
    // must be stored as part of the exercise statistics.
    //
    // Parameter:
    //     qd: Data for the current exercise. Null, if we are not generating an exercise. This data
    //         is used to control what grammar information to hide.
    // Returns:
    //     HTML code for displaying text.
    //
    public generateSentenceHtml(qd : QuizData) : string {
        DisplaySingleMonadObject.itemIndex = 0;  // Used in exercises where numbers replace text

        let sentenceTextArr : string[] = ['']; // The text is build in element [0] of this array. An
                                               // array is used because we want to use this variable
                                               // is a call-by-reference parameter.
        
        // Call DisplayMonadObject.generateHtml() on the top-most Emdros object (the 'Patriarch')
        $('#textarea').append(this.dispMonadObjects[this.dispMonadObjects.length-1][0].generateHtml(qd,sentenceTextArr,this.sentenceSetQuiz));

        if (configuration.databaseName=='ETCBC4') {
            // Generate indentation information

            // Calculate the min and max indentation by looping trough all HTML elements with indentation information
            let minindent : number;
            let maxindent : number;
            let all_c_a_t = $('#textarea').find('.xgrammar.clause_atom_tab');

            all_c_a_t.each( (index : number, el : Element) => {
                let indent = +$(el).attr('data-indent');
                if (index==0)
                    minindent = maxindent = indent;
                else {
                    if (indent<minindent)
                        minindent = indent;
                    if (indent>maxindent)
                        maxindent = indent;
                }
            });

            // Calculate width of indentation indicators
            $('#textarea').append('<div class="indentation" id="testwidth"></div>');
            let tw = $('#testwidth');
            tw.html(Dictionary.boxes(minindent,minindent,maxindent) + '&nbsp;&nbsp;');
            indentation_width = tw.width()+1;

            // Set indentation indicators
            all_c_a_t.each( (index : number, el : Element) => {
                let indent = +$(el).attr('data-indent');
                $(el).html(Dictionary.boxes(indent,minindent,maxindent) + '&nbsp;&nbsp;');
            });
        }

        // Set up handlers for display size changes (this also takes care of mouse hovering events)
        // and for mouse clicks
        resizer.addResizeListener(Dictionary.handleDisplaySize, this, 'xyzzy');
        Dictionary.handleDisplaySize(this);
        this.clickForGrammar();

        return sentenceTextArr[0];
    }

    //------------------------------------------------------------------------------------------
    // toolTipFunc method
    //
    // Generates HTML for the grammar information box.
    //
    // Patameters:
    //     x_this: The HTML element that triggered the displaying of the grammar information box.
    //     set_head: True if a header line should be generated. This parameter is true for mouse
    //               hover events, false for click events.
    // Returns:
    //     A tuple of two strings. The first string is the HTML for the grammar information box
    //     contents, the second string is the heading of the popup box, if any.
    //
    private toolTipFunc(x_this : Element, set_head : boolean) : [string, string] {
        // x_this identifies the HTML element that was clicked or hovered over. It has the attribute
        // 'data-idd', which contains the Emdros id_d, and the attribute 'data-mix' which identifies
        // the part of a multi-part object (such as a split clause).
        
        let monob   : MonadObject     = this.monads[+($(x_this).attr("data-idd"))]; // Current MonadObject
        let level   : number          = this.level[+($(x_this).attr("data-idd"))];  // Current level (0=word, 1=phrase, etc.)
        let mix     : number          = +$(x_this).attr("data-mix");                // Current part of multi-part object
        let sengram : SentenceGrammar = configuration.sentencegrammar[level];       // Sentence grammar information for the current level
        let res     : string          = '<table>';                                  // Will contain the resulting HTML

        if (set_head) {
            res += `<tr>
                        <td colspan="2" class="tooltiphead">${getObjectFriendlyName(sengram.objType)}</td>
                    </tr>`;
        }
        
        if (level===0 && !this.hideWord) { // Word level and we're not hiding the text
            res += `<tr>
                        <td>${localize('visual')}</td>
                        <td class="bol-tooltip leftalign ${charset.foreignClass}">${monob.mo.features[configuration.surfaceFeature]}</td>
                    </tr>`;
        }

        let map : util.str2str = {}; // Maps feature name => localized feature name

        // Popualate 'map':
        sengram.walkFeatureNames(sengram.objType, (whattype    : WHAT,
                                                   objType     : string,
                                                   origObjType : string,
                                                   featName    : string,
                                                   featNameLoc : string,
                                                   sgiObj      : SentenceGrammarItem) => {
                                                       if (whattype==WHAT.feature || whattype==WHAT.metafeature)
                                                           if (!mayShowFeature(objType, origObjType, featName, sgiObj))
                                                               return;
                                                       
                                                       if (whattype==WHAT.feature || whattype==WHAT.metafeature || whattype==WHAT.groupstart)
                                                           map[featName] = featNameLoc;
                                                   });

        // Generate HTML for each feature of the object
        sengram.walkFeatureValues(monob, mix, sengram.objType, false,
                                  (whattype    : WHAT,
                                   objType     : string,
                                   origObjType : string,
                                   featName    : string,
                                   featValLoc  : string,
                                   sgiObj      : SentenceGrammarItem) => {
                                       switch (whattype) {
                                       case WHAT.feature:
                                           if (mayShowFeature(objType, origObjType, featName, sgiObj)) {
                                               let wordclass : string; // HTML element class for displaying current feature value
                                               let fs : FeatureSetting = getFeatureSetting(objType, featName);
                                               if (featValLoc==='-')
                                                   wordclass = '';
                                               else if (fs.foreignText)
                                                   wordclass = charset.foreignClass;
                                               else if (fs.transliteratedText)
                                                   wordclass = charset.transliteratedClass;
                                               else
                                                   wordclass = '';
                                               res += `<tr>
                                                           <td>${map[featName]}</td>
                                                           <td class="bol-tooltip leftalign ${wordclass}">${featValLoc}</td>
                                                       </tr>`;
                                           }
                                           break;

                                       case WHAT.metafeature:
                                           if (mayShowFeature(objType, origObjType, featName, sgiObj)) {
                                               res += `<tr>
                                                           <td>${map[featName]}</td>
                                                           <td class="bol-tooltip leftalign">${featValLoc}</td>
                                                       </tr>`;
                                           }
                                           break;


                                       case WHAT.groupstart:
                                           res += `<tr>
                                                       <td><b>${map[featName]}:</b></td>
                                                       <td class="leftalign"></td>
                                                   </tr>`;
                                           break;
                                       }
                                   });
        
        return [res + '</table>', getObjectFriendlyName(sengram.objType)];
    }

    //------------------------------------------------------------------------------------------
    // getSingleMonadObject method
    //
    // Returns the SingleMonadObject (i.e. word) identified by a monad.
    //
    // Parameter:
    //     monad: The monad identifying the Emdros word object.
    // Returns:
    //     The SingleMonadObject associated with the specified monad.
    //
    public getSingleMonadObject(monad : number) : SingleMonadObject {
        return this.singleMonads[monad];
    }

}
