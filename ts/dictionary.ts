// -*- js -*-
// Copyright Â© 2018 by Ezer IT Consulting. All rights reserved. E-mail: claus@ezer.dk


// This code handles the interpretation of the 'dictionaries' variable generated by the server PHP code


//****************************************************************************************************
// DictionaryIf interface
//
// This interface and the 'dictionaries' variable are described in the Technical Documentation in the
// chapter entitled "The dictionaries Variable". They will not be documented here.


interface DictionaryIf {
    sentenceSets : MonadSet[];
    monadObjects: MonadObject[][][]; // First index is sentence set number, second index is level (word, phrase, clause etc.), third index gives the actual object
    bookTitle : string;
}


declare let dictionaries : DictionaryIf; // Generated by the server PHP code



//****************************************************************************************************
// Dictionary class
//
// This class is responsible for interpreting the contents of the 'dictionaries' variable and
// generating the corresponding HTML code.
//
class Dictionary {
    // The fields sentenceSet, monadobjects1 and bookTitle contain data extracted from the dictionaries variable.
    public sentenceSet   : MonadSet;        // A single MonadSet from dictionaries.sentenceSets
    public monadObjects1 : MonadObject[][]; // A single 2-D array from dictionaries.monadObjects.
                                            // The first index is level (word, phrase, clause etc.),
                                            // the second index gives the actual object
    public bookTitle     : string;          // Identical to dictionaries.bookTitle

    
    public monads           : MonadObject[]          = []; // Maps id_d => monad object
    public level            : number[]               = []; // Maps id_d => object level
    private singleMonads    : SingleMonadObject[]    = []; // Maps monad number => SingleMonadObject (words only)
    public dispMonadObjects : DisplayMonadObject[][] = []; // The Emdros objects to display.
                                                           // The first index is level (word, phrase, clause etc.),
                                                           // the second index gives the actual object

    private toolTipFunc : (x_this : Element, set_head : boolean) => util.Pair<string,string>; // first is content, second is heading


    //------------------------------------------------------------------------------------------
    // Constructor method
    //
    // Parameters:
    //     dictif: The DictionaryIf object to interpret.
    //     index: The entry in dictif.sentenceSets and dictif.monadObjects to interpret.
    //     inQuiz: True, if we are generating an exercize.
    //
    constructor(dictif : DictionaryIf, index : number, inQuiz : boolean) {
        // Save local copy of relevant information
        this.sentenceSet = dictif.sentenceSets[index];
        this.monadObjects1 = dictif.monadObjects[index];
        this.bookTitle = dictif.bookTitle;

        // Generate the 'singleMonads', 'monads' and 'level' maps.
        for (let level in this.monadObjects1) {
            let leveli : number = +level;
            if (isNaN(leveli)) continue; // Not numeric
            // leveli is 0 for word, 1 for phrase, etc. (or something similar depending on the database)

            for (let i in this.monadObjects1[leveli]) {
                if (isNaN(+i)) continue; // Not numeric

                let item : MonadObject = this.monadObjects1[leveli][+i]; // A single Emdros object
                if (leveli===0) 
                    this.singleMonads[getSingleInteger(item.mo.monadset)] = item as SingleMonadObject;
                this.monads[item.mo.id_d] = item;
                this.level[item.mo.id_d] = leveli;
            }
        }

        // Bind parents and children
	for (let i in this.monads) {
            if (isNaN(+i)) continue; // Not numeric

	    let parent : MonadObject = this.monads[+i];
	    for (let i2 in parent.children_idds) {
                if (isNaN(+i2)) continue; // Not numeric

		let child_idd : number = parent.children_idds[+i2];
                this.monads[child_idd].parent = parent;
            }
        }


        ///////////////////////////
        // Create display hierarchy
        ///////////////////////////

        // Single monads (i.e. words)
        this.dispMonadObjects.push([]);

        for (let se in this.singleMonads) {
            if (isNaN(+se)) continue; // Not numeric

            // singleMonads is sparsely populated
	    this.dispMonadObjects[0].push( new DisplaySingleMonadObject(this.singleMonads[+se],
                                                                        configuration.sentencegrammar[0].objType,
                                                                        inQuiz) );
        }

        // Multiple monads (i.e. phrases, clauses, etc.)
        for (let lev : number = 1; lev<configuration.maxLevels; ++lev) {
            let ldmo : DisplayMonadObject[] = []; // The Emdros objects at level 'lev'

            this.dispMonadObjects.push(ldmo);

            if (lev<configuration.maxLevels-1) { // Not top level
                for (let i in this.monadObjects1[lev]) {
                    if (isNaN(+i)) continue; // Not numeric

                    let monadObject : MonadObject = this.monadObjects1[lev][parseInt(i)]; // The current object

                    // Split object into contiguous segments
                    let segCount : number = monadObject.mo.monadset.segments.length;
                    
                    for (let mix : number = 0; mix<segCount; ++mix) {
                        let mp : MonadPair = monadObject.mo.monadset.segments[mix];
                        ldmo.push( new DisplayMultipleMonadObject(monadObject as MultipleMonadObject,
                                                                  configuration.sentencegrammar[lev].objType,
                                                                  lev,
                                                                  mp,
                                                                  mix,
                                                                  mix>0, 
                                                                  mix<segCount-1) );
                    }
                }

                // Sort ldmo in monad order
                ldmo.sort(
                    function(a : DisplayMonadObject, b : DisplayMonadObject) {
                        return a.range.low - b.range.low;
                    });
            }
            else { // Top level
                // At the top level there is always only one DisplayMultipleMonadObject
                let monadObject : MonadObject = this.monadObjects1[lev][0];
                ldmo.push( new DisplayMultipleMonadObject(monadObject as MultipleMonadObject,
                                                          'Patriarch', // The pseudo-name of the top-level object
                                                          lev,
                                                          monadObject.mo.monadset) );
            }
        }


        /////////////////////////////////////////////////////////
        // Construct child-parent linkage for DisplayMonadObjects
        /////////////////////////////////////////////////////////

        for (let lev : number = 1; lev<configuration.maxLevels; ++lev) {
            // Find constituent MonadObjects
            
            // Loop through monads at level lev
            for (let parentDmoIx in this.dispMonadObjects[lev]) {
                if (isNaN(+parentDmoIx)) continue; // Not numeric

                let parentDmo : DisplayMonadObject = this.dispMonadObjects[lev][+parentDmoIx];

                // Loop through mondads at child level
                for (let childDmoIx in this.dispMonadObjects[lev-1]) {
                    if (isNaN(+childDmoIx)) continue; // Not numeric

                    let childDmo : DisplayMonadObject = this.dispMonadObjects[lev-1][+childDmoIx];
                    if (childDmo.containedIn(parentDmo)) {
                        // We found a child
                        if (childDmo.parent!=undefined) throw 'BAD1'; // Ensures that the tree is properly constructed
                        childDmo.parent = parentDmo as DisplayMultipleMonadObject;
                        parentDmo.children.push(childDmo);
                    }
                }
            }
        }
    }

    //------------------------------------------------------------------------------------------
    // hoverForGrammar method
    //
    // Associate a grammar information box with each Emdros object. The grammar information box is
    // displayed when the mouse hovers over the object.
    //
    private hoverForGrammar() {
        let thisDict : Dictionary = this;

        // All display objects are identified with a "data-idd" attribute in the displaying HTML element. HERTIL
        
        if (useTooltip) {
            // Use the tooltip function of JQuery UI.
            $(document).tooltip(
                {
                    items: "[data-idd]",
                    disabled: false, 
                    content: function() { return thisDict.toolTipFunc(this,true).first; }
                });
        }
        else {
            // Poplulate the <div class="grammardisplay"> element with grammar information when the
            // mouse hovers over a displayed object.
            $("[data-idd]")
                .hover(
                    function() {
                        // Calculate vertical position of '.grammardisplay'.
                        // It should be placed at least 20px from top of window but not higher
                        // than '#textcontainer'
                        let scrTop   : number = $(window).scrollTop();
                        let qcTop    : number = $('#textcontainer').offset().top;
                        $('.grammardisplay')
                            .html(thisDict.toolTipFunc(this,true).first)
                            .css('top',Math.max(0,scrTop-qcTop+5))
                            .outerWidth($('#grammardisplaycontainer').outerWidth()-25) // 25px is a littel more than margin-right
                            .show();
                    },
                    function () {
                        $('.grammardisplay').hide();
                    }
                );
        }
    }

    private dontHoverForGrammar() {
        if (useTooltip)
            $(document).tooltip({items: "[data-idd]", disabled: true});
        else
            $("[data-idd]").off("mouseenter mouseleave");
    }
 
    private clickForGrammar() {
        $("[data-idd]").on('click', (event : any) => {
            let info = this.toolTipFunc(event.currentTarget,false);
            $('#grammar-info-label').html(info.second);
            $('#grammar-info-body').html(info.first);
            $('#grammar-info-dialog').modal('show');
        });
    }

    private static handleDisplaySize(thisDict : Dictionary) {
        switch (resizer.getWindowSize()) {
        case 'xs':
            thisDict.dontHoverForGrammar();
            break;

        default:
            thisDict.hoverForGrammar();
            break;
        }
    }

    private static boxes(num : number, minnum : number, maxnum : number) : string {
        let s = '';
        let numspaces = num < 10 ? num : num-1;  // If num has two digits, we write one space less

        for (let i=minnum; i<numspaces; ++i) 
            s += '\u00a0';

        s += num;

        for (let i=num; i<=maxnum; ++i)
            s += '\u25aa';

        return s;
    }


    public generateSentenceHtml(qd : QuizData) : string {
        DisplaySingleMonadObject.itemIndex = 0;
        let sentenceTextArr : string[] = [''];
        $('#textarea').append(this.dispMonadObjects[this.dispMonadObjects.length-1][0].generateHtml(qd,sentenceTextArr));

        if (configuration.databaseName=='ETCBC4') {
            // Generate indentation information

            let minindent : number;
            let maxindent : number;
            let all_c_a_t = $('#textarea').find('.xgrammar.clause_atom_tab');

            // Find minimum and maximum indentation
            all_c_a_t.each( (index : number, el : Element) => {
                let indent = +$(el).attr('data-indent');
                if (index==0)
                    minindent = maxindent = indent;
                else {
                    if (indent<minindent)
                        minindent = indent;
                    if (indent>maxindent)
                        maxindent = indent;
                }
            });

            // Calculate width of indentation indicators
            $('#textarea').append('<div class="indentation" id="testwidth"></div>');
            let tw = $('#testwidth');
            tw.html(Dictionary.boxes(minindent,minindent,maxindent) + '&nbsp;&nbsp;');
            indentation_width = tw.width()+1;

            // Set indentation indicators
            all_c_a_t.each( (index : number, el : Element) => {
                let indent = +$(el).attr('data-indent');
                $(el).html(Dictionary.boxes(indent,minindent,maxindent) + '&nbsp;&nbsp;');
            });
        }

        this.toolTipFunc  =
            function(x_this : Element, set_head : boolean) : util.Pair<string,string> {
                console.log(qd);
                let monob : MonadObject = this.monads[+($(x_this).attr("data-idd"))];
                let level : number = this.level[+($(x_this).attr("data-idd"))];
                let mix : number = +$(x_this).attr("data-mix");
                let sengram : SentenceGrammar = configuration.sentencegrammar[level];

                let res : string = '<table>';

                if (set_head)
                    res += '<tr><td colspan="2" class="tooltiphead">{0}</td></tr>'.format(getObjectFriendlyName(sengram.objType));

                if (level===0 && (!qd || !qd.quizFeatures.dontShow))
                    res += '<tr><td>{2}</td><td class="bol-tooltip leftalign {0}">{1}</td></tr>'.format(charset.foreignClass, monob.mo.features[configuration.surfaceFeature],localize('visual'));
                
                let map : Array<string> = [];

                sengram.walkFeatureNames(sengram.objType,
                                         (whattype:number, objType:string, origObjType:string, featName:string, featNameLoc:string, sgiObj:SentenceGrammarItem) => {
                                             if (whattype==WHAT.feature || whattype==WHAT.metafeature)
                                                 if (!mayShowFeature(objType, origObjType, featName, sgiObj))
                                                     return;
                                             
                                             if (whattype==WHAT.feature || whattype==WHAT.metafeature || whattype==WHAT.groupstart)
                                                 map[featName] = featNameLoc;
                                         });

                sengram.walkFeatureValues(monob, mix, sengram.objType, false,
                                          (whattype:number, objType:string, origObjType:string, featName:string, featValLoc:string, sgiObj:SentenceGrammarItem) => {
                                              switch (whattype) {
                                              case WHAT.feature:
                                                  if (mayShowFeature(objType, origObjType, featName, sgiObj)) {
                                                      let wordclass : string;
                                                      let fs : FeatureSetting = getFeatureSetting(objType,featName);
                                                      if (fs.foreignText)
                                                          wordclass = charset.foreignClass;
                                                      else if (fs.transliteratedText)
                                                          wordclass = charset.transliteratedClass;
                                                      else
                                                          wordclass = '';
                                                      res += '<tr><td>{0}</td><td class="bol-tooltip leftalign {2}">{1}</td></tr>'.format(map[featName], featValLoc, featValLoc==='-' ? '' : wordclass);
                                                  }
                                                  break;

                                              case WHAT.metafeature:
                                                  if (mayShowFeature(objType, origObjType, featName, sgiObj))
                                                      res += '<tr><td>{0}</td><td class="bol-tooltip leftalign">{1}</td></tr>'.format(map[featName], featValLoc);
                                                  break;


                                              case WHAT.groupstart:
                                                  res += '<tr><td><b>{0}:</b></td><td class="leftalign"></td></tr>'.format(map[featName]);
                                                  break;
                                              }
                                          });
                
                return new util.Pair(res + '</table>', getObjectFriendlyName(sengram.objType));
            };

        resizer.addResizeListener(Dictionary.handleDisplaySize, this, 'xyzzy');
        this.clickForGrammar();
        Dictionary.handleDisplaySize(this);

        return sentenceTextArr[0];
    }

    public getSingleMonadObject(monad : number) : SingleMonadObject {
        return this.singleMonads[monad];
    }

}
